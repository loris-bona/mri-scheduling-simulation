---
title: "MRI Scheduling Simulation"
author: "Mischa Hermans"
date: "2026-01-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## 1. Overview

This notebook simulates an MRI appointment scheduling system and uses Monte Carlo replication to compare two scheduling policies under uncertainty in demand and scan durations.

We model the system in two linked layers:

1. Planning layer  
   Patients call during the day and are scheduled at the first available appointment time after the call day. Appointments are booked using fixed planned slot lengths that depend only on the patient type.

2. Execution layer  
   On the appointment day, the actual treatment durations are random. This layer simulates the daily operation of the MRI machines and determines realized waiting times, overtime, and other performance measures.

Two scheduling policies are compared:  

1. Old policy  
  Each patient type is assigned to its own machine (Type 1 to Machine 1, Type 2 to Machine 2). Scheduling is performed independently per machine.

2. New policy  
  Both machines can serve both patient types. For each incoming call, the system books the earliest feasible appointment slot across machines.  

All randomness is generated outside the scheduling logic:

- Type 1 calls are modeled parametrically using a Poisson number of calls per day, with call times uniformly distributed over working hours.  

- Type 2 calls and scan durations are generated empirically by resampling historical observations from ScanRecords.csv.

One replication represents one independent operational period consisting of a fixed number of working days. Replications are independent and identically distributed. Repeating the simulation many times allows us to estimate average performance and quantify variability across operational periods.

For each replication, we report the following performance measures:  

- waiting time until appointment, measured in working hours only  
- mean overtime per day  
- probability of overtime  
- utilization per machine  

---

## 2. Model parameters

```{r}
# Simulation horizon and Monte Carlo settings
random_seed            <- 1
number_replications    <- 50
number_simulation_days <- 60

# Working hours definition
work_start_hour        <- 8
work_end_hour          <- 17
work_hours_per_day     <- work_end_hour - work_start_hour

# Planned slot lengths
planned_slot_length_hours_by_type <- c(
  "1" = 0.43,
  "2" = 0.68
)

# Type 1 arrival and duration parameters
type1_daily_arrival_rate <- 16.9524
type1_duration_mean      <- 0.4285
type1_duration_sd        <- 0.0973

# Data source for Type 2 empirical inputs
scan_records_path <- "ScanRecords.csv"
```

---

## 3. Random input generation

This section generates the stochastic arrivals and scan durations used in the simulation, based on the parameters specified in Section 2.

For patient type 1, the number of calls per day is generated from a Poisson distribution. Call times within a day are sampled uniformly over working hours. Scan durations are generated from a normal distribution.

For patient type 2, no parametric assumptions are made. Both the daily number of calls and the scan durations are generated by resampling historical observations from the data.

```{r}
suppressPackageStartupMessages({
  library(readr)
  library(dplyr)
  library(lubridate)
  library(tidyr)
})

# Load and clean historical scan records
raw_scan_records <- read_csv(scan_records_path, show_col_types = FALSE)

clean_scan_records <- raw_scan_records %>%
  mutate(
    PatientType = factor(PatientType),
    Date        = as.Date(Date),
    Time        = as.numeric(Time),
    Duration    = as.numeric(Duration)
  ) %>%
  filter(!is.na(Date), !is.na(Time), !is.na(Duration), Duration > 0) %>%
  mutate(
    hour_part    = floor(Time),
    minute_part  = round((Time - hour_part) * 60),
    hour_part    = hour_part + (minute_part %/% 60),
    minute_part  = minute_part %% 60,
    CallDateTime = as.POSIXct(Date, tz = "UTC") +
                   hours(hour_part) + minutes(minute_part)
  )

# Compute daily arrivals per patient type
daily_arrivals_by_type <- clean_scan_records %>%
  mutate(call_date = as.Date(CallDateTime)) %>%
  count(PatientType, call_date, name = "arrivals")

all_workdays <- tibble(
  call_date = seq(min(daily_arrivals_by_type$call_date),
                  max(daily_arrivals_by_type$call_date),
                  by = "day")
) %>%
  filter(wday(call_date, week_start = 1) <= 5)

daily_arrivals_by_type <- daily_arrivals_by_type %>%
  group_by(PatientType) %>%
  right_join(all_workdays, by = "call_date") %>%
  mutate(arrivals = replace_na(arrivals, 0L)) %>%
  ungroup()

# Empirical distributions used for Type 2
type2_daily_arrivals_distribution <- daily_arrivals_by_type %>%
  filter(PatientType == "Type 2") %>%
  pull(arrivals)

type2_duration_distribution <- clean_scan_records %>%
  filter(PatientType == "Type 2") %>%
  pull(Duration)

# Type 1 call generator: Poisson arrivals, uniform call times
generate_type1_call_times <- function(type1_daily_rate) {
  number_calls <- rpois(1, type1_daily_rate)
  if (number_calls == 0) return(numeric(0))
  sort(runif(number_calls, work_start_hour, work_end_hour))
}

# Type 2 call generator: resample historical daily demand
generate_type2_call_times <- function(simulation_day) {
  number_calls <- sample(type2_daily_arrivals_distribution, 1, replace = TRUE)
  if (number_calls == 0) return(numeric(0))
  sort(runif(number_calls, work_start_hour, work_end_hour))
}

# Duration samplers used during execution
duration_sampler_by_type <- list(
  "1" = function() max(rnorm(1, type1_duration_mean, type1_duration_sd), 0),
  "2" = function() sample(type2_duration_distribution, 1, replace = TRUE)
)
```

---

## 4. Simulation framework

The simulation consists of two layers:  
1. Planning layer: appointment booking using fixed slot lengths  
2. Execution layer: realized scan durations, overtime, and utilization  

Waiting time is measured as elapsed time during working hours between the day of the call and the appointment time.

```{r}
# Convert (day, hour) into elapsed working hours
to_working_hours <- function(day, hour) {
  (day - 1) * work_hours_per_day + (hour - work_start_hour)
}

# Planned schedule state: last planned end time per machine per day
initialize_planned_schedule <- function() {
  list("1" = numeric(0), "2" = numeric(0))
}

get_planned_day_end <- function(planned_end_times, day) {
  # If no bookings yet on that day, machine is free at work start
  day_key <- as.character(day)
  if (!is.na(planned_end_times[day_key])) planned_end_times[day_key] else work_start_hour
}

set_planned_day_end <- function(planned_end_times, day, value) {
  planned_end_times[as.character(day)] <- value
  planned_end_times
}

# Book the earliest feasible slot on a single machine
book_earliest_slot_on_machine <- function(
  planned_end_times,
  earliest_day,
  slot_length_hours
) {
  current_day <- earliest_day

  repeat {
    day_end_time <- get_planned_day_end(planned_end_times, current_day)

    # Accept slot only if it finishes within working hours
    if (day_end_time + slot_length_hours <= work_end_hour) {
      appointment_start <- day_end_time
      planned_end_times <- set_planned_day_end(
        planned_end_times,
        current_day,
        day_end_time + slot_length_hours
      )

      return(list(
        updated_planned_end = planned_end_times,
        appointment_day     = current_day,
        appointment_start   = appointment_start
      ))
    }

    # Otherwise try next working day
    current_day <- current_day + 1
  }
}

# Policy logic: choose machine and slot under old vs new policy
choose_appointment_under_policy <- function(
  planned_schedule_by_machine,
  patient_type,
  earliest_day,
  slot_length_hours,
  scheduling_policy
) {
  if (scheduling_policy == "old") {
    # Dedicated machines by patient type
    assigned_machine <- if (patient_type == 1) "1" else "2"

    booking <- book_earliest_slot_on_machine(
      planned_schedule_by_machine[[assigned_machine]],
      earliest_day,
      slot_length_hours
    )

    return(list(
      machine                  = assigned_machine,
      appointment_day          = booking$appointment_day,
      appointment_start        = booking$appointment_start,
      updated_planned_end_time = booking$updated_planned_end
    ))
  }

  # New policy: try both machines and pick earliest available slot
  booking_machine_1 <- book_earliest_slot_on_machine(
    planned_schedule_by_machine[["1"]],
    earliest_day,
    slot_length_hours
  )

  booking_machine_2 <- book_earliest_slot_on_machine(
    planned_schedule_by_machine[["2"]],
    earliest_day,
    slot_length_hours
  )

  machine_1_is_earlier <-
    booking_machine_1$appointment_day < booking_machine_2$appointment_day ||
    (
      booking_machine_1$appointment_day == booking_machine_2$appointment_day &&
      booking_machine_1$appointment_start <= booking_machine_2$appointment_start
    )

  chosen <- if (machine_1_is_earlier) booking_machine_1 else booking_machine_2
  chosen_machine <- if (machine_1_is_earlier) "1" else "2"

  list(
    machine                  = chosen_machine,
    appointment_day          = chosen$appointment_day,
    appointment_start        = chosen$appointment_start,
    updated_planned_end_time = chosen$updated_planned_end
  )
}

# Add a single booking to the booking table
append_booking_record <- function(
  bookings_table,
  call_day,
  call_hour,
  patient_type,
  machine,
  appointment_day,
  appointment_start
) {
  rbind(
    bookings_table,
    data.frame(
      call_day          = call_day,
      call_hour         = call_hour,
      patient_type      = patient_type,
      machine           = machine,
      appointment_day   = appointment_day,
      appointment_start = appointment_start
    )
  )
}

# Schedule one incoming call and update system state
schedule_patient_call <- function(
  schedule_state,
  call_day,
  call_hour,
  patient_type,
  planned_slot_length_hours_by_type,
  scheduling_policy
) {
  earliest_appointment_day <- call_day + 1
  slot_length_hours <- planned_slot_length_hours_by_type[as.character(patient_type)]

  decision <- choose_appointment_under_policy(
    planned_schedule_by_machine = schedule_state$planned_schedule,
    patient_type                = patient_type,
    earliest_day                = earliest_appointment_day,
    slot_length_hours           = slot_length_hours,
    scheduling_policy           = scheduling_policy
  )

  # Update planned schedule and booking log
  schedule_state$planned_schedule[[decision$machine]] <- decision$updated_planned_end_time
  schedule_state$bookings <- append_booking_record(
    schedule_state$bookings,
    call_day, call_hour, patient_type,
    decision$machine,
    decision$appointment_day,
    decision$appointment_start
  )

  schedule_state
}

# Execution layer: realized durations, overtime, utilization
simulate_realized_execution <- function(bookings, duration_sampler_by_type) {
  bookings$actual_duration <- vapply(
    seq_len(nrow(bookings)),
    function(i) duration_sampler_by_type[[as.character(bookings$patient_type[i])]](),
    numeric(1)
  )

  bookings <- bookings[order(bookings$appointment_day,
                             bookings$machine,
                             bookings$appointment_start), ]

  appointment_days <- unique(bookings$appointment_day)
  overtime_by_day <- setNames(rep(0, length(appointment_days)), as.character(appointment_days))
  busy_time_by_machine <- c("1" = 0, "2" = 0)

  for (day in appointment_days) {
    for (machine in c("1", "2")) {
      indices <- which(bookings$appointment_day == day & bookings$machine == machine)
      if (length(indices) == 0) next

      current_time <- work_start_hour

      for (i in indices) {
        current_time <- max(current_time, bookings$appointment_start[i])
        current_time <- current_time + bookings$actual_duration[i]
        busy_time_by_machine[machine] <- busy_time_by_machine[machine] + bookings$actual_duration[i]
      }

      overtime_by_day[as.character(day)] <- overtime_by_day[as.character(day)] +
                                            max(0, current_time - work_end_hour)
    }
  }

  utilization_by_machine <- busy_time_by_machine /
    (work_hours_per_day * length(appointment_days))

  list(
    overtime_by_day        = overtime_by_day,
    utilization_by_machine = utilization_by_machine
  )
}

# One replication of the system
run_single_replication <- function(
  number_days,
  scheduling_policy,
  planned_slot_length_hours_by_type,
  type1_daily_arrival_rate,
  type1_call_generator,
  type2_call_generator,
  duration_sampler_by_type
) {
  schedule_state <- list(
    planned_schedule = initialize_planned_schedule(),
    bookings         = data.frame()
  )

  for (day in 1:number_days) {
    for (call_hour in type1_call_generator(type1_daily_arrival_rate)) {
      schedule_state <- schedule_patient_call(
        schedule_state, day, call_hour, 1,
        planned_slot_length_hours_by_type, scheduling_policy
      )
    }

    for (call_hour in type2_call_generator(day)) {
      schedule_state <- schedule_patient_call(
        schedule_state, day, call_hour, 2,
        planned_slot_length_hours_by_type, scheduling_policy
      )
    }
  }

  bookings <- schedule_state$bookings

  bookings$waiting_time_working_hours <-
    to_working_hours(bookings$appointment_day, bookings$appointment_start) -
    to_working_hours(bookings$call_day, bookings$call_hour)

  execution <- simulate_realized_execution(bookings, duration_sampler_by_type)

  list(
    mean_waiting_time_by_type = tapply(bookings$waiting_time_working_hours,
                                       bookings$patient_type, mean),
    p90_waiting_time_by_type  = tapply(bookings$waiting_time_working_hours,
                                       bookings$patient_type,
                                       function(x) quantile(x, 0.9)),
    mean_overtime_per_day     = mean(execution$overtime_by_day),
    probability_overtime      = mean(execution$overtime_by_day > 0),
    utilization_by_machine    = execution$utilization_by_machine
  )
}
```

---

## 5. Simulation study

```{r}
set.seed(random_seed)

results_old_policy <- replicate(
  number_replications,
  run_single_replication(
    number_simulation_days,
    "old",
    planned_slot_length_hours_by_type,
    type1_daily_arrival_rate,
    generate_type1_call_times,
    generate_type2_call_times,
    duration_sampler_by_type
  ),
  simplify = FALSE
)

results_new_policy <- replicate(
  number_replications,
  run_single_replication(
    number_simulation_days,
    "new",
    planned_slot_length_hours_by_type,
    type1_daily_arrival_rate,
    generate_type1_call_times,
    generate_type2_call_times,
    duration_sampler_by_type
  ),
  simplify = FALSE
)
```

---

## 6. Results summary

```{r}
summarize_replications <- function(results, extractor) {
  values <- vapply(results, extractor, numeric(1))
  c(mean = mean(values), variance = var(values))
}

summary_table <- rbind(
  old_wait_type1 = summarize_replications(results_old_policy,
                                         function(r) r$mean_waiting_time_by_type["1"]),
  new_wait_type1 = summarize_replications(results_new_policy,
                                         function(r) r$mean_waiting_time_by_type["1"]),
  old_wait_type2 = summarize_replications(results_old_policy,
                                         function(r) r$mean_waiting_time_by_type["2"]),
  new_wait_type2 = summarize_replications(results_new_policy,
                                         function(r) r$mean_waiting_time_by_type["2"]),

  old_overtime   = summarize_replications(results_old_policy,
                                         function(r) r$mean_overtime_per_day),
  new_overtime   = summarize_replications(results_new_policy,
                                         function(r) r$mean_overtime_per_day),

  old_util_m1    = summarize_replications(results_old_policy,
                                         function(r) r$utilization_by_machine["1"]),
  new_util_m1    = summarize_replications(results_new_policy,
                                         function(r) r$utilization_by_machine["1"]),
  old_util_m2    = summarize_replications(results_old_policy,
                                         function(r) r$utilization_by_machine["2"]),
  new_util_m2    = summarize_replications(results_new_policy,
                                         function(r) r$utilization_by_machine["2"]),

  old_util_avg   = summarize_replications(results_old_policy,
                                         function(r) mean(r$utilization_by_machine)),
  new_util_avg   = summarize_replications(results_new_policy,
                                         function(r) mean(r$utilization_by_machine))
)

knitr::kable(round(summary_table, 3))
```