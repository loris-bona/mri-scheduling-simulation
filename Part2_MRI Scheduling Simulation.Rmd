---
title: "Part II: MRI Scheduling Simulation"
author: "Group 1"
date: "2026-01-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## 1. Overview

This notebook simulates an MRI appointment scheduling system and uses Monte Carlo replication to compare two scheduling policies under uncertainty in demand and scan durations.

We model the system in two linked layers:

1. **Planning layer**
   Patients call during the day and are scheduled at the first available appointment time after the call day. Appointments are booked using fixed planned slot lengths that depend only on the patient type.

2. **Execution layer**  
   On the appointment day, the actual treatment durations are random. This layer simulates the daily operation of the MRI machines and determines realized waiting times, overtime, and other performance measures.

Two scheduling policies are compared:  

1. **Old policy**  
  Each patient type is assigned to its own machine (Type 1 to Machine 1, Type 2 to Machine 2). Scheduling is performed independently per machine.

2. **Flexible policy**  
  Both machines can serve both patient types. For each incoming call, the system books the earliest feasible appointment slot across machines.  

**Randomness enters the model through arrivals and scan durations:**

- **Type 1 patients:**  
  The number of calls per day follows a Poisson distribution, with call times uniformly distributed over working hours. Scan durations are modeled using a normal distribution with mean and standard deviation estimated from historical data.

- **Type 2 patients:**  
  No parametric assumptions are used. Both the daily number of calls and the scan durations are generated by resampling historical observations from `ScanRecords.csv`.

A single replication simulates one independent “operational period” of  
`warmup_days + number_simulation_days` working days with newly generated random arrivals and durations.  
Performance is computed using only the days after the warm-up. Repeating many replications provides Monte Carlo estimates of the expected KPIs and their variability.

---

## 2. Model parameters

```{r}
# Simulation horizon and Monte Carlo settings
random_seed            <- 1
number_replications    <- 200
number_replications_sensitivity <- 100
number_simulation_days <- 60
warmup_days <- 20

# Working hours definition
work_start_hour        <- 8
work_end_hour          <- 17
work_hours_per_day     <- work_end_hour - work_start_hour

# Baseline planned slot lengths per patient type (average duration)
planned_slot_length_hours_by_type <- c(
  "1" = 0.43,
  "2" = 0.68
)

# Type 1 arrival and duration parameters (outcomes of part 1)
type1_daily_arrival_rate <- 16.9524
type1_duration_mean      <- 0.4285
type1_duration_sd        <- 0.0973

# Data source for Type 2 empirical inputs
scan_records_path <- "ScanRecords.csv"
```

---

## 3. Random input generation

This section generates the stochastic arrivals and scan durations used in the simulation, based on the parameters specified in Section 2.

For patient type 1, the number of calls per day is generated from a Poisson distribution. Call times within a day are sampled uniformly over working hours. Scan durations are generated from a normal distribution.

For patient type 2, no parametric assumptions are made. Both the daily number of calls and the scan durations are generated by resampling historical observations from the data.

```{r}
suppressPackageStartupMessages({
  library(readr)
  library(dplyr)
  library(lubridate)
  library(tidyr)
})

# Load and clean historical scan records
raw_scan_records <- read_csv(scan_records_path, show_col_types = FALSE)

clean_scan_records <- raw_scan_records %>%
  mutate(
    PatientType = factor(PatientType),
    Date        = as.Date(Date),
    Time        = as.numeric(Time),
    Duration    = as.numeric(Duration)
  ) %>%
  filter(!is.na(Date), !is.na(Time), !is.na(Duration), Duration > 0) %>%
  mutate(
    hour_part    = floor(Time),
    minute_part  = round((Time - hour_part) * 60),
    hour_part    = hour_part + (minute_part %/% 60),
    minute_part  = minute_part %% 60,
    CallDateTime = as.POSIXct(Date, tz = "UTC") +
                   hours(hour_part) + minutes(minute_part)
  )

# Compute daily arrivals per patient type
daily_arrivals_by_type <- clean_scan_records %>%
  mutate(call_date = as.Date(CallDateTime)) %>%
  count(PatientType, call_date, name = "arrivals")

all_workdays <- tibble(
  call_date = seq(min(daily_arrivals_by_type$call_date),
                  max(daily_arrivals_by_type$call_date),
                  by = "day")
) %>%
  filter(wday(call_date, week_start = 1) <= 5)

daily_arrivals_by_type <- daily_arrivals_by_type %>%
  group_by(PatientType) %>%
  right_join(all_workdays, by = "call_date") %>%
  mutate(arrivals = replace_na(arrivals, 0L)) %>%
  ungroup()

# Empirical distributions used for Type 2
type2_daily_arrivals_distribution <- daily_arrivals_by_type %>%
  filter(PatientType == "Type 2") %>%
  pull(arrivals)

type2_duration_distribution <- clean_scan_records %>%
  filter(PatientType == "Type 2") %>%
  pull(Duration)

# Type 1 call generating: Poisson arrivals, uniform call times
generate_type1_call_times <- function(type1_daily_rate) {
  number_calls <- rpois(1, type1_daily_rate)
  if (number_calls == 0) return(numeric(0))
  sort(runif(number_calls, work_start_hour, work_end_hour))
}

# Type 2 call generating: resample historical daily demand
generate_type2_call_times <- function(simulation_day) {
  number_calls <- sample(type2_daily_arrivals_distribution, 1, replace = TRUE)
  if (number_calls == 0) return(numeric(0))
  sort(runif(number_calls, work_start_hour, work_end_hour))
}

# Duration sampling used during execution
duration_sampler_by_type <- list(
  "1" = function() max(rnorm(1, type1_duration_mean, type1_duration_sd), 0),
  "2" = function() sample(type2_duration_distribution, 1, replace = TRUE)
)
```

---

## 4. Simulation framework

The simulation consists of two layers:  
1. Planning layer: appointment booking using fixed slot lengths  
2. Execution layer: realized scan durations, overtime, and utilization  

Waiting time (access delay) is measured as elapsed time during working hours between the day of the call and the appointment time.

```{r}
# Convert (day, hour) into elapsed working hours
to_working_hours <- function(day, hour) {
  (day - 1) * work_hours_per_day + (hour - work_start_hour)
}

working_wait_hours <- function(call_day, call_hour, appt_day, actual_start) {
  if (is.na(actual_start) || is.na(call_hour) || is.na(appt_day) || is.na(call_day)) return(NA_real_)
  if (appt_day <= call_day) return(0)

  # Count waiting only within working hours on appointment day
  start_cap <- min(actual_start, work_end_hour)

  # Remaining working hours on the call day
  w_call_day <- max(0, work_end_hour - max(call_hour, work_start_hour))

  # Full working days between call and appointment
  full_days <- max(0, appt_day - call_day - 1)
  w_full_days <- full_days * work_hours_per_day

  # Working hours elapsed on appointment day before service
  w_appt_day <- max(0, start_cap - work_start_hour)

  w_call_day + w_full_days + w_appt_day
}

# Access delay: waiting time until the scheduled appointment start
working_wait_to_appt_hours <- function(call_day, call_hour, appt_day, appt_start) {
  working_wait_hours(call_day, call_hour, appt_day, appt_start)
}

# Appointment lateness (in hours): how late we start compared to the scheduled start
appointment_lateness_hours <- function(appt_start, actual_start) {
  if (is.na(appt_start) || is.na(actual_start)) return(NA_real_)
  pmax(0, actual_start - appt_start)
}

# Initialize planned end times per machine per day
initialize_planned_schedule <- function() {
  list("1" = numeric(0), "2" = numeric(0))
}

get_planned_day_end <- function(planned_end_times, day) {
  # Return last planned end time on this day
  day_key <- as.character(day)
  if (!is.na(planned_end_times[day_key])) planned_end_times[day_key] else work_start_hour
}

set_planned_day_end <- function(planned_end_times, day, value) {
  # Update planned end time for a given day
  planned_end_times[as.character(day)] <- value
  planned_end_times
}

# Book the earliest feasible appointment on one machine
book_earliest_slot_on_machine <- function(
  planned_end_times,
  earliest_day,
  slot_length_hours
) {
  current_day <- earliest_day

  repeat {
    # Planned end time of the machine on this day
    day_end_time <- get_planned_day_end(planned_end_times, current_day)

    # Accept if the slot fits within working hours
    if (day_end_time + slot_length_hours <= work_end_hour) {
      appointment_start <- day_end_time
      planned_end_times <- set_planned_day_end(
        planned_end_times,
        current_day,
        day_end_time + slot_length_hours
      )

      return(list(
        updated_planned_end = planned_end_times,
        appointment_day     = current_day,
        appointment_start   = appointment_start
      ))
    }

    # Otherwise move to the next working day
    current_day <- current_day + 1
  }
}

# Select machine and appointment slot under the chosen policy
choose_appointment_under_policy <- function(
  planned_schedule_by_machine,
  patient_type,
  earliest_day,
  slot_length_hours,
  scheduling_policy
) {
  if (scheduling_policy == "old") {
    # Assign patient to a dedicated machine by type
    assigned_machine <- if (patient_type == 1) "1" else "2"

    booking <- book_earliest_slot_on_machine(
      planned_schedule_by_machine[[assigned_machine]],
      earliest_day,
      slot_length_hours
    )

    return(list(
      machine                  = assigned_machine,
      appointment_day          = booking$appointment_day,
      appointment_start        = booking$appointment_start,
      updated_planned_end_time = booking$updated_planned_end
    ))
  }

  # Under the new policy, evaluate both machines
  booking_machine_1 <- book_earliest_slot_on_machine(
    planned_schedule_by_machine[["1"]],
    earliest_day,
    slot_length_hours
  )

  booking_machine_2 <- book_earliest_slot_on_machine(
    planned_schedule_by_machine[["2"]],
    earliest_day,
    slot_length_hours
  )
  
  # Choose the machine with the earlier feasible appointment
  machine_1_is_earlier <-
    booking_machine_1$appointment_day < booking_machine_2$appointment_day ||
    (
      booking_machine_1$appointment_day == booking_machine_2$appointment_day &&
      booking_machine_1$appointment_start <= booking_machine_2$appointment_start
    )

  chosen <- if (machine_1_is_earlier) booking_machine_1 else booking_machine_2
  chosen_machine <- if (machine_1_is_earlier) "1" else "2"

  list(
    machine                  = chosen_machine,
    appointment_day          = chosen$appointment_day,
    appointment_start        = chosen$appointment_start,
    updated_planned_end_time = chosen$updated_planned_end
  )
}

# Append one scheduled appointment to the booking log
append_booking_record <- function(
  bookings_table,
  call_day,
  call_hour,
  patient_type,
  machine,
  appointment_day,
  appointment_start
) {
  rbind(
    bookings_table,
    data.frame(
      call_day          = call_day,
      call_hour         = call_hour,
      patient_type      = patient_type,
      machine           = machine,
      appointment_day   = appointment_day,
      appointment_start = appointment_start
    )
  )
}

# Schedule a single patient call and update the system state
schedule_patient_call <- function(
  schedule_state,
  call_day,
  call_hour,
  patient_type,
  planned_slot_length_hours_by_type,
  scheduling_policy
) {
  # Appointments are booked no earlier than the next working day
  earliest_appointment_day <- call_day + 1
  
  # Planned slot length depends on patient type
  slot_length_hours <- planned_slot_length_hours_by_type[as.character(patient_type)]

  decision <- choose_appointment_under_policy(
    planned_schedule_by_machine = schedule_state$planned_schedule,
    patient_type                = patient_type,
    earliest_day                = earliest_appointment_day,
    slot_length_hours           = slot_length_hours,
    scheduling_policy           = scheduling_policy
  )

  # Apply booking decision to planned schedule and booking log
  schedule_state$planned_schedule[[decision$machine]] <- decision$updated_planned_end_time
  schedule_state$bookings <- append_booking_record(
    schedule_state$bookings,
    call_day, call_hour, patient_type,
    decision$machine,
    decision$appointment_day,
    decision$appointment_start
  )

  schedule_state
}

# Simulate realized service times and resulting overtime/utilization
simulate_realized_execution <- function(bookings, duration_sampler_by_type, kpi_days) {
  
  # Sample actual scan durations by patient type
  bookings$actual_duration <- vapply(
    seq_len(nrow(bookings)),
    function(i) duration_sampler_by_type[[as.character(bookings$patient_type[i])]](),
    numeric(1)
  )
  
  # Process jobs in chronological order within each day and machine
  bookings <- bookings[order(bookings$appointment_day,
                             bookings$machine,
                             bookings$appointment_start), ]
  
  bookings$actual_start <- NA_real_

  appointment_days <- kpi_days

  # Store realized overtime per day for each machine
  overtime_by_day_machine <- list(
    "1" = setNames(rep(0, length(appointment_days)), as.character(appointment_days)),
    "2" = setNames(rep(0, length(appointment_days)), as.character(appointment_days))
  )
  
  busy_time_by_machine <- c("1" = 0, "2" = 0)
  
  for (day in appointment_days) {
    for (machine in c("1", "2")) {
      indices <- which(bookings$appointment_day == day & bookings$machine == machine)
  
      current_time <- work_start_hour
  
      if (length(indices) > 0) {
        for (i in indices) {
          # Start when both the machine and the patient’s planned slot are ready
          actual_start_i <- max(current_time, bookings$appointment_start[i])
          bookings$actual_start[i] <- actual_start_i
          current_time <- actual_start_i + bookings$actual_duration[i]
          busy_time_by_machine[machine] <- busy_time_by_machine[machine] + bookings$actual_duration[i]
        }
      }
      
      # Overtime is any work completed after the scheduled end of day
      overtime_by_day_machine[[machine]][as.character(day)] <- max(0, current_time - work_end_hour)
    }
  }
  
  # Total daily overtime across both machines
  overtime_by_day_overall <- overtime_by_day_machine[["1"]] + overtime_by_day_machine[["2"]]
  
  utilization_by_machine <- busy_time_by_machine /
    (work_hours_per_day * length(appointment_days))
  
  list(
    bookings_with_actual_times = bookings,
    overtime_by_day_overall    = overtime_by_day_overall,
    overtime_by_day_machine    = overtime_by_day_machine,
    utilization_by_machine     = utilization_by_machine
  )
}

# One Monte Carlo replication: generate calls, schedule, then simulate execution and KPIs
run_single_replication <- function(
  number_days,
  scheduling_policy,
  planned_slot_length_hours_by_type,
  type1_daily_arrival_rate,
  type1_call_generator,
  type2_call_generator,
  duration_sampler_by_type
) {
  schedule_state <- list(
    planned_schedule = initialize_planned_schedule(),
    bookings         = data.frame()
  )

  for (day in 1:(number_days + warmup_days)) {
    for (call_hour in type1_call_generator(type1_daily_arrival_rate)) {
      schedule_state <- schedule_patient_call(
        schedule_state, day, call_hour, 1,
        planned_slot_length_hours_by_type, scheduling_policy
      )
    }

    for (call_hour in type2_call_generator(day)) {
      schedule_state <- schedule_patient_call(
        schedule_state, day, call_hour, 2,
        planned_slot_length_hours_by_type, scheduling_policy
      )
    }
  }
  
  # Keep only appointments occurring after warm-up
  bookings <- schedule_state$bookings
  bookings_kpi <- subset(bookings, appointment_day > warmup_days)
  
  # Simulate only the appointment days that actually occur in the KPI set
  kpi_days <- (warmup_days + 1):(warmup_days + number_days)
  
  execution <- simulate_realized_execution(bookings_kpi, duration_sampler_by_type, kpi_days)
  
  bookings_exec <- execution$bookings_with_actual_times
  bookings_exec <- bookings_exec[!is.na(bookings_exec$actual_start), ]

  # Access delay: from call until scheduled appointment time
  bookings_exec$access_delay_working_hours <- mapply(
    working_wait_to_appt_hours,
    bookings_exec$call_day,
    bookings_exec$call_hour,
    bookings_exec$appointment_day,
    bookings_exec$appointment_start
  )
  
  # Appointment lateness: actual start minus scheduled start
  bookings_exec$appointment_lateness_hours <- mapply(
    appointment_lateness_hours,
    bookings_exec$appointment_start,
    bookings_exec$actual_start
  )
  
  bookings_kpi <- bookings_exec

  list(
    mean_access_delay_overall = mean(bookings_kpi$access_delay_working_hours, na.rm = TRUE),
    p90_access_delay_overall  = as.numeric(quantile(bookings_kpi$access_delay_working_hours, 0.9, na.rm = TRUE)),
  
    mean_access_delay_by_type = tapply(bookings_kpi$access_delay_working_hours,
                                       bookings_kpi$patient_type, mean, na.rm = TRUE),
    p90_access_delay_by_type  = tapply(bookings_kpi$access_delay_working_hours,
                                       bookings_kpi$patient_type,
                                       function(x) quantile(x, 0.9, na.rm = TRUE)),
  
    mean_lateness_overall = mean(bookings_kpi$appointment_lateness_hours, na.rm = TRUE),
    mean_lateness_by_type = tapply(bookings_kpi$appointment_lateness_hours,
                                   bookings_kpi$patient_type, mean, na.rm = TRUE),
  
    mean_overtime_overall_per_day = mean(execution$overtime_by_day_overall),
    mean_overtime_m1_per_day      = mean(execution$overtime_by_day_machine[["1"]]),
    mean_overtime_m2_per_day      = mean(execution$overtime_by_day_machine[["2"]]),
    prob_overtime_overall         = mean(execution$overtime_by_day_overall > 0),
    prob_overtime_m1              = mean(execution$overtime_by_day_machine[["1"]] > 0),
    prob_overtime_m2              = mean(execution$overtime_by_day_machine[["2"]] > 0),
    utilization_by_machine        = execution$utilization_by_machine
  )
}
```

---

## 5. Simulation study

This section provides a baseline reference for system performance.  
Planned appointment slot lengths are set equal to the mean scan duration of each patient type, and the simulation is used to obtain an initial indication of waiting times, overtime, and utilization under both scheduling policies.  
These results serve as a starting point for the sensitivity and optimization analyses that follow.

```{r}
set.seed(random_seed)

# Monte Carlo replications under the old (dedicated-machine) policy
results_old_policy <- replicate(
  number_replications,
  run_single_replication(
    number_simulation_days,
    "old",
    planned_slot_length_hours_by_type,
    type1_daily_arrival_rate,
    generate_type1_call_times,
    generate_type2_call_times,
    duration_sampler_by_type
  ),
  simplify = FALSE
)

# Monte Carlo replications under the new (flexible-machine) policy
results_new_policy <- replicate(
  number_replications,
  run_single_replication(
    number_simulation_days,
    "new",
    planned_slot_length_hours_by_type,
    type1_daily_arrival_rate,
    generate_type1_call_times,
    generate_type2_call_times,
    duration_sampler_by_type
  ),
  simplify = FALSE
)
```

---

## 6. Results summary

```{r}
summarize_replications <- function(results, extractor) {
  values <- vapply(results, extractor, numeric(1))
  c(mean = mean(values), variance = var(values))
}

summary_table <- rbind(
  old_wait_overall = summarize_replications(results_old_policy,
                                            function(r) r$mean_waiting_time_overall),
  new_wait_overall = summarize_replications(results_new_policy,
                                            function(r) r$mean_waiting_time_overall),
  old_wait_type1 = summarize_replications(results_old_policy,
                                         function(r) r$mean_waiting_time_by_type["1"]),
  new_wait_type1 = summarize_replications(results_new_policy,
                                         function(r) r$mean_waiting_time_by_type["1"]),
  old_wait_type2 = summarize_replications(results_old_policy,
                                         function(r) r$mean_waiting_time_by_type["2"]),
  new_wait_type2 = summarize_replications(results_new_policy,
                                         function(r) r$mean_waiting_time_by_type["2"]),
  old_ot_overall = summarize_replications(results_old_policy,
                                         function(r) r$mean_overtime_overall_per_day),
  new_ot_overall = summarize_replications(results_new_policy,
                                         function(r) r$mean_overtime_overall_per_day),
  old_ot_m1      = summarize_replications(results_old_policy,
                                         function(r) r$mean_overtime_m1_per_day),
  new_ot_m1      = summarize_replications(results_new_policy,
                                         function(r) r$mean_overtime_m1_per_day),
  old_ot_m2      = summarize_replications(results_old_policy,
                                         function(r) r$mean_overtime_m2_per_day),
  new_ot_m2      = summarize_replications(results_new_policy,
                                         function(r) r$mean_overtime_m2_per_day),
  old_util_m1    = summarize_replications(results_old_policy,
                                         function(r) r$utilization_by_machine["1"]),
  new_util_m1    = summarize_replications(results_new_policy,
                                         function(r) r$utilization_by_machine["1"]),
  old_util_m2    = summarize_replications(results_old_policy,
                                         function(r) r$utilization_by_machine["2"]),
  new_util_m2    = summarize_replications(results_new_policy,
                                         function(r) r$utilization_by_machine["2"]),

  old_util_avg   = summarize_replications(results_old_policy,
                                         function(r) mean(r$utilization_by_machine)),
  new_util_avg   = summarize_replications(results_new_policy,
                                         function(r) mean(r$utilization_by_machine))
)

knitr::kable(round(summary_table, 3))
```

## 7. Slot-length sensitivity analysis

In this section we study how the choice of planned slot length affects system performance.
We scale the baseline slot lengths for both patient types by a common multiplier and evaluate
the resulting changes in overall access delay, overall overtime, and overall utilization.
For each slot-length setting, performance measures are estimated using Monte Carlo replication
under the new scheduling policy.

```{r}
# Slot-length grid
baseline_slots <- planned_slot_length_hours_by_type
slot_multipliers <- seq(0.60, 1.40, by = 0.05)
```

```{r}
# summarize overall KPIs for a single slot-length setting
summarize_slot_setting <- function(multiplier) {

  slots <- baseline_slots * multiplier
  
  set.seed(random_seed + round(multiplier * 1000))

  results <- replicate(
    number_replications_sensitivity,
    run_single_replication(
      number_simulation_days,
      "new",
      slots,
      type1_daily_arrival_rate,
      generate_type1_call_times,
      generate_type2_call_times,
      duration_sampler_by_type
    ),
    simplify = FALSE
  )

  c(
    wait_overall     = mean(vapply(results,
                                   function(r) r$mean_waiting_time_overall,
                                   numeric(1))),
    overtime_overall = mean(vapply(results,
                                   function(r) r$mean_overtime_overall_per_day,
                                   numeric(1))),
    util_overall     = mean(vapply(results,
                                   function(r) mean(r$utilization_by_machine),
                                   numeric(1)))
  )
}
```

```{r}
# Run sensitivity analysis over slot-length grid
results_matrix <- t(vapply(slot_multipliers,
                           summarize_slot_setting,
                           numeric(3)))

slot_results <- data.frame(
  multiplier       = slot_multipliers,
  slot_type1_hours = baseline_slots["1"] * slot_multipliers,
  slot_type2_hours = baseline_slots["2"] * slot_multipliers,
  wait_overall     = results_matrix[, "wait_overall"],
  overtime_overall = results_matrix[, "overtime_overall"],
  util_overall     = results_matrix[, "util_overall"]
)
```

```{r, fig.width=12, fig.height=4}
par(mfrow = c(1, 3), mar = c(4, 4, 3, 1))

x <- (slot_results$multiplier - 1) * baseline_slots["1"] * 60

plot(x, slot_results$wait_overall, type = "b",
     xlab = "Assumed extra scan time relative to baseline (minutes)",
     ylab = "Overall mean waiting time (working hours)",
     main = "Waiting time vs slot length")

plot(x, 60 * slot_results$overtime_overall, type = "b",
     xlab = "Assumed extra scan time relative to baseline (minutes)",
     ylab = "Overall mean overtime per day (minutes)",
     main = "Overtime vs slot length")

plot(x, 100 * slot_results$util_overall, type = "b",
     xlab = "Assumed extra scan time relative to baseline (minutes)",
     ylab = "Overall mean utilization (%)",
     main = "Utilization vs slot length")

par(mfrow = c(1, 1))
```

## 8. Preference-based slot length optimization

In this section, we optimize the planned appointment slot lengths for Type~1 and Type~2 patients using a preference-based objective function. For each scheduling policy (dedicated/old and flexible/new), a grid of candidate slot-length combinations is evaluated using the simulation model. For every preference scenario, the **top three** slot-length designs with the lowest objective value are identified and reported.

The objective function aggregates multiple performance measures:
- mean access delay / waiting time for Type~1 patients ($W_1$),
- mean access delay / waiting time for Type~2 patients ($W_2$),
- lateness ($L$),
- mean daily overtime ($O$),
- average machine utilization ($U$).

To ensure comparability across metrics, each performance measure is normalized relative to the baseline slot-length design used earlier in the analysis.

---

### 8.1 Grid search settings and preference scenarios

Different hospital preference scenarios are considered by varying the weights assigned to the performance measures in the objective function. These scenarios reflect alternative managerial priorities:

- **Balanced**: Equal importance is assigned to patient waiting times, overtime, and utilization, representing a neutral trade-off between operational efficiency and patient experience.
- **Patient-focused**: Higher weight is placed on waiting times for both patient types and lateness, prioritizing access and timeliness of care.
- **Overtime-focused**: Overtime is weighted more heavily, reflecting a preference for staff workload reduction.
- **Utilization-focused**: Higher emphasis is placed on machine utilization, aiming to maximize efficient use of expensive MRI capacity.

For each combination of scheduling policy and preference scenario, the grid search identifies the slot-length designs that minimize the corresponding objective value. 

```{r}
# Replications used during grid evaluation
number_replications_grid <- 50     

# Candidate slot-length grid (in hours)
slot_type1_min_hours <- (25/60) - (15/60)
slot_type1_max_hours <- (25/60) + (15/60)
slot_type1_step_hours <- 5/60

slot_type2_min_hours <- (40/60) - (15/60)
slot_type2_max_hours <- (40/60) + (15/60)
slot_type2_step_hours <- 5/60

preference_weights <- data.frame(
  scenario = c("Balanced", "Patient-focused", "Overtime-focused", "Utilization-focused"),

  w_W1 = c(0.20, 0.25, 0.12, 0.12),
  w_W2 = c(0.20, 0.25, 0.12, 0.12),
  w_L  = c(0.20, 0.25, 0.12, 0.12),
  w_O  = c(0.20, 0.15, 0.52, 0.12),
  w_U  = c(0.20, 0.10, 0.12, 0.52),

  stringsAsFactors = FALSE
)
```

---

### 8.2 Functions to evaluate a slot design and compute the objective score

```{r}
# Build the candidate grid
create_slot_grid_2d <- function() {
  slot_type1_values <- seq(slot_type1_min_hours, slot_type1_max_hours, by = slot_type1_step_hours)
  slot_type2_values <- seq(slot_type2_min_hours, slot_type2_max_hours, by = slot_type2_step_hours)

  expand.grid(
    slot_type1_hours = as.numeric(slot_type1_values),
    slot_type2_hours = as.numeric(slot_type2_values),
    KEEP.OUT.ATTRS = FALSE,
    stringsAsFactors = FALSE
  )
}

# Evaluate a single (slot1, slot2) design under one policy
evaluate_slot_design <- function(policy_name, slot_type1_hours, slot_type2_hours, n_replications) {

  slot_type1_hours <- as.numeric(slot_type1_hours)[1]
  slot_type2_hours <- as.numeric(slot_type2_hours)[1]

  candidate_slots <- c("1" = slot_type1_hours, "2" = slot_type2_hours)

  replication_results <- replicate(
    n_replications,
    run_single_replication(
      number_days                       = number_simulation_days,
      scheduling_policy                 = policy_name,
      planned_slot_length_hours_by_type = candidate_slots,
      type1_daily_arrival_rate          = type1_daily_arrival_rate,
      type1_call_generator              = generate_type1_call_times,
      type2_call_generator              = generate_type2_call_times,
      duration_sampler_by_type          = duration_sampler_by_type
    ),
    simplify = FALSE
  )

  W  <- mean(vapply(replication_results, function(r) r$mean_access_delay_overall, numeric(1)), na.rm = TRUE)
  W1 <- mean(vapply(replication_results, function(r) r$mean_access_delay_by_type["1"], numeric(1)), na.rm = TRUE)
  W2 <- mean(vapply(replication_results, function(r) r$mean_access_delay_by_type["2"], numeric(1)), na.rm = TRUE)
  
  L  <- mean(vapply(replication_results, function(r) r$mean_lateness_overall, numeric(1)), na.rm = TRUE)

  O  <- mean(vapply(replication_results, function(r) r$mean_overtime_overall_per_day, numeric(1)), na.rm = TRUE)

  U  <- mean(vapply(replication_results, function(r) mean(r$utilization_by_machine), numeric(1)), na.rm = TRUE)

  data.frame(
    policy = policy_name,
    slot_type1_hours = slot_type1_hours,
    slot_type2_hours = slot_type2_hours,
    W = W, W1 = W1, W2 = W2, L = L, O = O, U = U,
    stringsAsFactors = FALSE
  )
}

# Scale values to [0,1] using the minimum and the 95th percentile to reduce the effect of extreme values
robust_minmax <- function(x, lower_q = 0.00, upper_q = 0.95, eps = 1e-9) {
  lo <- as.numeric(quantile(x, lower_q, na.rm = TRUE))
  hi <- as.numeric(quantile(x, upper_q, na.rm = TRUE))

  x_cap <- pmin(pmax(x, lo), hi)

  denom <- max(hi - lo, eps)
  (x_cap - lo) / denom
}

# Normalize all performance measures for a grid under one policy to a common [0,1] scale
normalize_grid_metrics <- function(grid_metrics) {
  df <- grid_metrics

  df$W1_norm <- robust_minmax(df$W1)
  df$W2_norm <- robust_minmax(df$W2)
  df$L_norm  <- robust_minmax(df$L)
  df$O_norm  <- robust_minmax(df$O)

  df$U_penalty <- 1 - df$U
  df$U_norm <- robust_minmax(df$U_penalty)

  df
}

# Compute weighted objective J from normalized KPIs
compute_J_from_norm <- function(df_norm, weights_row) {
  with(df_norm,
       weights_row$w_W1 * W1_norm +
       weights_row$w_W2 * W2_norm +
       weights_row$w_L  * L_norm  +
       weights_row$w_O  * O_norm  +
       weights_row$w_U  * U_norm)
}
```

---

### 8.3 Run the grid search and extract the top 3 designs

```{r}
set.seed(random_seed)

slot_grid <- create_slot_grid_2d()

# Evaluate all grid points under each policy
grid_metrics_old <- do.call(rbind, lapply(seq_len(nrow(slot_grid)), function(i) {
  evaluate_slot_design("old", slot_grid$slot_type1_hours[i], slot_grid$slot_type2_hours[i], number_replications_grid)
}))
grid_metrics_new <- do.call(rbind, lapply(seq_len(nrow(slot_grid)), function(i) {
  evaluate_slot_design("new", slot_grid$slot_type1_hours[i], slot_grid$slot_type2_hours[i], number_replications_grid)  
}))

# Attach objective score J for each preference scenario
score_grid_for_policy <- function(grid_metrics, weights_table) {

  # Normalize KPIs once per policy over the evaluated grid
  grid_norm <- normalize_grid_metrics(grid_metrics)

  out <- do.call(rbind, lapply(seq_len(nrow(weights_table)), function(s) {
    w <- weights_table[s, ]

    scored <- grid_norm
    scored$scenario <- w$scenario

    scored$J <- compute_J_from_norm(scored, w)

    scored
  }))

  out
}

scored_old <- score_grid_for_policy(grid_metrics_old, preference_weights)
scored_new <- score_grid_for_policy(grid_metrics_new, preference_weights)

scored_all <- rbind(scored_old, scored_new)

top3_table <- do.call(rbind, lapply(split(scored_all, list(scored_all$scenario, scored_all$policy), drop = TRUE), function(df) {
  df <- df[order(df$J), ]
  df <- df[1:3, ]
  df$rank <- 1:nrow(df)
  df
}))

top3_table$slot_T1_min <- round(60 * top3_table$slot_type1_hours)
top3_table$slot_T2_min <- round(60 * top3_table$slot_type2_hours)

top3_table_report <- top3_table[, c(
  "scenario", "policy", "rank",
  "slot_T1_min", "slot_T2_min",
  "J", "W", "W1", "W2", "L", "O", "U"
)]

knitr::kable(
  top3_table_report,
  digits = 4,
  caption = "Top 3 slot-length designs per preference scenario and policy."
)
``` 
